
FULLSTACK PROJECT INTEGRATION RULES (Java Spring Boot + React/TypeScript)

This prompt is loaded for fullstack projects with both frontend/ and backend/ folders.
These rules ensure PERFECT integration between backend APIs and frontend consumption.

═══════════════════════════════════════════════════════════════════════════════
⚠️ MANDATORY: READ ENTITY_SPECS FROM PLAN FIRST!
═══════════════════════════════════════════════════════════════════════════════

BEFORE writing ANY file, find <entity_specs> in the plan context.
Use EXACT field names from entity_specs across ALL files.

RULE: If entity_specs defines a field as {fieldName}: {Type}
- Backend Entity: private {Type} {fieldName};
- Backend DTO: private {Type} {fieldName};
- Backend Service: dto.set{FieldName}(entity.get{FieldName}());
- Frontend types: {fieldName}: {tsType};
- Frontend components: {{item}.{fieldName}}

❌ NEVER invent or guess field names
❌ NEVER use different names than entity_specs defines
✅ ALWAYS copy exact field names from entity_specs

═══════════════════════════════════════════════════════════════════════════════
⚠️ CRITICAL: BACKEND-FRONTEND TYPE SYNCHRONIZATION
═══════════════════════════════════════════════════════════════════════════════

The #1 cause of fullstack build failures is TYPE MISMATCH between backend
API responses and frontend TypeScript interfaces. FOLLOW THESE RULES:

1. SPRING BOOT PAGINATION - Page<T> FORMAT (MANDATORY)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

BACKEND (Java Controller):
```java
@GetMapping
public ResponseEntity<Page<{Entity}Dto>> getAll(
    @RequestParam(defaultValue = "0") int page,
    @RequestParam(defaultValue = "10") int size) {
    return ResponseEntity.ok(service.findAll(PageRequest.of(page, size)));
}
```

ACTUAL JSON RESPONSE from Spring Boot Page<T>:
```json
{
  "content": [...],           // Array of items - ALWAYS use this name
  "totalElements": 100,       // Total count - ALWAYS use this name
  "totalPages": 10,           // Number of pages
  "number": 0,                // Current page (0-indexed!) - ALWAYS use this name
  "size": 10,                 // Items per page
  "first": true,              // Is first page
  "last": false,              // Is last page
  "empty": false              // Is empty
}
```

FRONTEND (TypeScript) - MUST MATCH EXACTLY:
```typescript
// src/types/index.ts - PageResponse type (REQUIRED)
export interface PageResponse<T> {
  content: T[];               // NOT 'data', 'items', '{entities}'
  totalElements: number;      // NOT 'total', 'count'
  totalPages: number;
  number: number;             // NOT 'page', 'currentPage' (0-indexed!)
  size: number;
  first: boolean;
  last: boolean;
  empty: boolean;
}

// Usage in service:
const response = await api.get<PageResponse<{Entity}>>('/api/{entities}');
set{Entities}(response.content);        // NOT response.data
setTotal(response.totalElements);       // NOT response.total
setCurrentPage(response.number);        // NOT response.page
```

❌ WRONG - DO NOT create custom list response types:
```typescript
interface {Entity}ListResponse {
  {entities}: {Entity}[];     // WRONG! Spring uses 'content'
  total: number;              // WRONG! Spring uses 'totalElements'
  page: number;               // WRONG! Spring uses 'number'
}
```

2. ENTITY/DTO TO TYPESCRIPT TYPE MAPPING
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

TYPE MAPPING RULES (Java -> TypeScript):
- Long, Integer -> number
- String -> string
- BigDecimal, Double -> number
- Boolean -> boolean
- LocalDate, LocalDateTime -> string (ISO format)
- List<T> -> T[]

BACKEND Entity Pattern:
```java
@Entity
@Table(name = "{table_name}")
public class {Entity} {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private {Type1} {field1};
    private {Type2} {field2};
    // ... fields from entity_specs
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    // getters and setters for EACH field...
}
```

BACKEND DTO Pattern:
```java
public class {Entity}Dto {
    private Long id;
    private {Type1} {field1};
    private {Type2} {field2};
    // ... same fields from entity_specs
    private String createdAt;
    private String updatedAt;
    // getters and setters for EACH field...
}
```

FRONTEND Type Pattern (MUST MATCH DTO):
```typescript
// src/types/index.ts
export interface {Entity} {
  id: number;
  {field1}: {tsType1};
  {field2}: {tsType2};
  // ... same fields from entity_specs (use TypeScript types)
  createdAt: string;
  updatedAt: string;
}

// Request DTOs
export interface Create{Entity}Request {
  {field1}: {tsType1};
  {field2}: {tsType2};
  // ... fields for creation (exclude id, createdAt, updatedAt)
}

export interface Update{Entity}Request {
  {field1}?: {tsType1};
  {field2}?: {tsType2};
  // ... optional fields for update
}
```

3. API SERVICE CONFIGURATION
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

FRONTEND API Service (src/services/api.ts):
```typescript
import axios from 'axios';

// Use relative path for Vite proxy OR env variable for Docker
const API_BASE_URL = import.meta.env.VITE_API_URL || '/api';

const api = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000,
  headers: { 'Content-Type': 'application/json' },
});

export default api;
```

FRONTEND Entity Service Pattern (src/services/{entity}Service.ts):
```typescript
import api from './api';
import { {Entity}, Create{Entity}Request, Update{Entity}Request, PageResponse } from '../types';

export const {entity}Service = {
  getAll: async (page = 0, size = 10) => {
    const response = await api.get<PageResponse<{Entity}>>(`/{entities}?page=${page}&size=${size}`);
    return response.data;
  },

  getById: async (id: number) => {
    const response = await api.get<{Entity}>(`/{entities}/${id}`);
    return response.data;
  },

  create: async (data: Create{Entity}Request) => {
    const response = await api.post<{Entity}>('/{entities}', data);
    return response.data;
  },

  update: async (id: number, data: Update{Entity}Request) => {
    const response = await api.put<{Entity}>(`/{entities}/${id}`, data);
    return response.data;
  },

  delete: async (id: number) => {
    await api.delete(`/{entities}/${id}`);
  },
};
```

4. VITE CONFIGURATION FOR FULLSTACK
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

FRONTEND vite.config.ts - REQUIRED:
```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    host: '0.0.0.0',
    port: 3000,
    hmr: false,  // Required for Docker preview
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        secure: false,
      },
    },
  },
});
```

FRONTEND src/vite-env.d.ts - REQUIRED FOR import.meta.env:
```typescript
/// <reference types="vite/client" />
interface ImportMetaEnv {
  readonly VITE_API_URL: string;
}
interface ImportMeta {
  readonly env: ImportMetaEnv;
}
```

5. BACKEND CORS CONFIGURATION
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

BACKEND CorsConfig.java - REQUIRED:
```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins("*")
            .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS")
            .allowedHeaders("*");
    }
}
```

6. DOCKERFILE RULES (ALPINE VS DEBIAN)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⚠️ CRITICAL: Alpine images use APK, not APT-GET!

Alpine base images (node:20-alpine, eclipse-temurin:17-jre-alpine):
- Use: apk add --no-cache curl
- NOT: apt-get install -y curl

BACKEND Dockerfile (Alpine):
```dockerfile
FROM maven:3.9-eclipse-temurin-17-alpine as build
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src src
RUN mvn clean package -DskipTests

FROM eclipse-temurin:17-jre-alpine
WORKDIR /app
RUN apk add --no-cache curl
COPY --from=build /app/target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

7. DOCKER COMPOSE FOR FULLSTACK
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

docker-compose.yml:
```yaml
services:
  backend:
    build: ./backend
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker

  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    depends_on:
      - backend
    environment:
      - VITE_API_URL=http://backend:8080/api
```

8. COMPONENT PROPS CONSISTENCY
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

When creating components, define props interface using entity_specs fields:

```typescript
// Props interface - use {Entity} type from types/index.ts
interface {Entity}CardProps {
  {entity}: {Entity};
  onEdit: ({entity}: {Entity}) => void;
  onDelete: (id: number) => void;
}

// Component - access fields from entity_specs
export default function {Entity}Card({ {entity}, onEdit, onDelete }: {Entity}CardProps) {
  return (
    <div>
      <h3>{{entity}.{field1}}</h3>
      <p>{{entity}.{field2}}</p>
      <button onClick={() => onEdit({entity})}>Edit</button>
      <button onClick={() => onDelete({entity}.id)}>Delete</button>
    </div>
  );
}
```

═══════════════════════════════════════════════════════════════════════════════
VERIFICATION CHECKLIST
═══════════════════════════════════════════════════════════════════════════════

Before generating ANY file in a fullstack project:

[ ] Read entity_specs from plan - use EXACT field names
[ ] PageResponse<T> uses: content, totalElements, number (Spring Boot format)
[ ] Frontend types match backend DTO property names EXACTLY
[ ] Field names consistent across Entity/DTO/Service/Frontend
[ ] vite-env.d.ts exists for import.meta.env support
[ ] API service uses /api base URL (for Vite proxy)
[ ] Dockerfile uses apk (not apt-get) for Alpine images
