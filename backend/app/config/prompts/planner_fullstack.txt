
FULLSTACK PROJECT PLANNING RULES (Java Spring Boot + React/TypeScript)

When planning a fullstack project, you MUST ensure proper integration between
backend APIs and frontend consumption. This prevents 90% of build failures.

═══════════════════════════════════════════════════════════════════════════════
CRITICAL RULES FOR STUDENT PROJECTS
═══════════════════════════════════════════════════════════════════════════════

1. NO SECURITY - Skip spring-boot-starter-security (causes 403 errors)
2. NO LOMBOK - Write explicit getters/setters
3. ENUMS in separate files
4. SPRING BOOT 3.x uses jakarta.* (NOT javax.*)
5. ALPINE Dockerfile uses apk (NOT apt-get)

═══════════════════════════════════════════════════════════════════════════════
ENTITY FIELD SPECIFICATIONS (LAYER 2 - CRITICAL)
═══════════════════════════════════════════════════════════════════════════════

For EACH entity, you MUST define exact fields in a <entity_specs> section.
This ensures Writer uses SAME field names across backend AND frontend.

FORMAT (fill in based on project requirements):
<entity_specs>
ENTITY: {EntityName}
BACKEND_FIELDS:
  - id: Long (primary key)
  - {field1}: {JavaType1}
  - {field2}: {JavaType2}
  - {field3}: {JavaType3}
  - createdAt: LocalDateTime
  - updatedAt: LocalDateTime
FRONTEND_FIELDS:
  - id: number
  - {field1}: {tsType1}
  - {field2}: {tsType2}
  - {field3}: {tsType3}
  - createdAt: string
  - updatedAt: string
TABLE: {table_name}
API_PATH: /api/{entities}

ENUM: {EnumName}
VALUES: {VALUE1}, {VALUE2}, {VALUE3}
</entity_specs>

TYPE MAPPING (Java -> TypeScript):
- Long, Integer, Double, BigDecimal -> number
- String -> string
- Boolean -> boolean
- LocalDate, LocalDateTime -> string (ISO format)
- List<T> -> T[]

Writer will use these EXACT field names in:
- Backend Entity class (private fields + getters + setters)
- Backend DTO class (same fields)
- Backend Service (convertToDto uses these field names)
- Frontend types/index.ts (TypeScript interfaces)
- Frontend services (API calls return these fields)
- Frontend components (access these field names)

═══════════════════════════════════════════════════════════════════════════════
MANDATORY FILES FOR FULLSTACK PROJECTS
═══════════════════════════════════════════════════════════════════════════════

BACKEND (Spring Boot) - Required Files:
```
backend/
├── src/main/java/com/app/
│   ├── config/
│   │   └── CorsConfig.java          # CORS for frontend access
│   ├── controller/
│   │   └── {Entity}Controller.java  # REST endpoints
│   ├── service/
│   │   └── {Entity}Service.java     # Business logic
│   ├── repository/
│   │   └── {Entity}Repository.java  # JPA repository
│   ├── entity/
│   │   └── {Entity}.java            # JPA entity with getters/setters
│   ├── dto/
│   │   └── {Entity}Dto.java         # Data transfer object
│   └── Application.java
├── src/main/resources/
│   └── application.yml              # Database, CORS config
├── pom.xml
└── Dockerfile
```

FRONTEND (React + TypeScript) - Required Files:
```
frontend/
├── src/
│   ├── types/
│   │   └── index.ts                 # ALL types matching backend DTOs
│   ├── services/
│   │   ├── api.ts                   # Axios config with interceptors
│   │   └── {entity}Service.ts       # API calls for entity
│   ├── components/
│   │   └── {Entity}Card.tsx         # Reusable components
│   ├── pages/
│   │   ├── {Entity}ListPage.tsx     # List/table page
│   │   └── {Entity}DetailPage.tsx   # Detail/form page
│   ├── hooks/
│   │   └── use{Entity}.ts           # Data fetching hooks
│   ├── App.tsx
│   ├── main.tsx
│   └── vite-env.d.ts                # REQUIRED for import.meta.env
├── package.json
├── vite.config.ts                   # MUST have proxy config
├── tsconfig.json
├── tailwind.config.js
├── postcss.config.js
├── index.html
└── Dockerfile
```

ROOT:
```
docker-compose.yml                   # Both services
.env.example                         # Environment template
```

═══════════════════════════════════════════════════════════════════════════════
CRITICAL: TYPE SYNCHRONIZATION PLANNING
═══════════════════════════════════════════════════════════════════════════════

When planning files, the types MUST be planned to match the backend exactly.
Include EXACT FIELDS from <entity_specs> in each file description.

1. PLAN BACKEND ENTITY FIRST:
   <file path="backend/src/main/java/com/{project}/model/{Entity}.java" priority="6">
     <description>
       JPA Entity for {table_name} table.
       FIELDS: [copy BACKEND_FIELDS from entity_specs]
       Include: @Entity, @Table, @Id, @GeneratedValue
       Include: explicit getter and setter for EACH field
       Include: no-arg constructor, @PrePersist, @PreUpdate
     </description>
     <exports>{Entity}</exports>
   </file>

2. PLAN BACKEND DTO:
   <file path="backend/src/main/java/com/{project}/dto/{Entity}Dto.java" priority="11">
     <description>
       DTO for {Entity} API responses.
       FIELDS: [copy BACKEND_FIELDS from entity_specs]
       SAME FIELDS as {Entity} entity.
       Include: explicit getter and setter for EACH field
     </description>
     <exports>{Entity}Dto</exports>
   </file>

3. PLAN BACKEND SERVICE:
   <file path="backend/src/main/java/com/{project}/service/{Entity}Service.java" priority="21">
     <description>
       Service for {Entity} CRUD operations.
       ENTITY_FIELDS: [list field names from entity_specs]

       Methods:
       - findAll(): List&lt;{Entity}Dto&gt;
       - findAll(Pageable): Page&lt;{Entity}Dto&gt;
       - findById(Long id): {Entity}Dto
       - create({Entity}Dto dto): {Entity}Dto
       - update(Long id, {Entity}Dto dto): {Entity}Dto
       - delete(Long id): void

       convertToDto must map: [all fields from entity_specs]
       convertToEntity must map: [all fields except id, createdAt, updatedAt]
     </description>
     <exports>{Entity}Service</exports>
   </file>

4. PLAN FRONTEND TYPES TO MATCH DTO:
   <file path="frontend/src/types/index.ts" priority="15">
     <description>
       TypeScript types matching backend DTOs EXACTLY:

       {Entity} interface:
       [copy FRONTEND_FIELDS from entity_specs]

       PageResponse&lt;T&gt; (Spring Boot format - REQUIRED):
       - content: T[]
       - totalElements: number
       - totalPages: number
       - number: number (0-indexed!)
       - size: number
       - first: boolean
       - last: boolean
       - empty: boolean

       Create{Entity}Request, Update{Entity}Request
     </description>
     <exports>{Entity}, PageResponse, Create{Entity}Request, Update{Entity}Request</exports>
   </file>

═══════════════════════════════════════════════════════════════════════════════
PAGINATION TYPE - SPRING BOOT Page<T> FORMAT
═══════════════════════════════════════════════════════════════════════════════

ALWAYS plan frontend PageResponse to match Spring Boot's Page<T>:

Frontend types/index.ts MUST include:
```typescript
interface PageResponse<T> {
  content: T[];           // NOT 'data', 'items', or entity name
  totalElements: number;  // NOT 'total', 'count'
  totalPages: number;
  number: number;         // NOT 'page', 'currentPage' (0-indexed!)
  size: number;
  first: boolean;
  last: boolean;
  empty: boolean;
}
```

❌ WRONG - DO NOT PLAN custom list response types:
```typescript
interface {Entity}ListResponse {
  {entities}: {Entity}[];  // WRONG! Spring uses 'content'
  total: number;           // WRONG! Spring uses 'totalElements'
  page: number;            // WRONG! Spring uses 'number'
}
```

═══════════════════════════════════════════════════════════════════════════════
MANDATORY CONFIGURATION FILES
═══════════════════════════════════════════════════════════════════════════════

1. VITE CONFIG with proxy:
   <file path="frontend/vite.config.ts" priority="3">
     <description>
       Vite config with:
       - React plugin
       - Server host: 0.0.0.0, port: 3000
       - HMR disabled for Docker
       - Proxy: /api -> http://backend:8080
     </description>
   </file>

2. VITE-ENV.D.TS (REQUIRED):
   <file path="frontend/src/vite-env.d.ts" priority="4">
     <description>
       Vite environment types for import.meta.env:
       - ImportMetaEnv with VITE_API_URL
       - ImportMeta with env property
     </description>
   </file>

3. CORS CONFIG:
   <file path="backend/src/main/java/com/app/config/CorsConfig.java" priority="5">
     <description>
       Spring CORS configuration:
       - Allow origins: localhost:3000, localhost:5173
       - Allow methods: GET, POST, PUT, DELETE, PATCH
       - Allow credentials: true
     </description>
   </file>

4. DOCKER COMPOSE:
   <file path="docker-compose.yml" priority="2">
     <description>
       Docker Compose for fullstack:
       - backend service: Spring Boot on 8080
       - frontend service: Vite on 3000, depends on backend
       - db service: PostgreSQL on 5432 (if needed)
     </description>
   </file>

═══════════════════════════════════════════════════════════════════════════════
COMPONENT PROPS PLANNING
═══════════════════════════════════════════════════════════════════════════════

When planning components, explicitly list required props:

<file path="frontend/src/components/{Entity}Card.tsx" priority="30">
  <description>
    {Entity} card component
    Props: {entity}: {Entity}, onEdit: (e: {Entity}) => void, onDelete: (id: number) => void
    Displays: [list display fields from FRONTEND_FIELDS]
  </description>
  <exports>{Entity}Card</exports>
</file>

<file path="frontend/src/pages/{Entity}ListPage.tsx" priority="40">
  <description>
    {Entity} list page
    - Uses {entity}Service.getAll() for PageResponse&lt;{Entity}&gt;
    - Accesses response.content for {entity} array
    - Accesses response.totalElements for total count
    - Accesses response.number for current page
  </description>
  <exports>{Entity}ListPage</exports>
</file>

<file path="frontend/src/services/{entity}Service.ts" priority="20">
  <description>
    API service for {Entity} CRUD:
    - getAll(page, size) returns PageResponse&lt;{Entity}&gt;
    - getById(id) returns {Entity}
    - create(data) returns {Entity}
    - update(id, data) returns {Entity}
    - delete(id) returns void

    Uses PageResponse type with content, totalElements, number properties
  </description>
  <exports>{entity}Service</exports>
</file>

═══════════════════════════════════════════════════════════════════════════════
PLANNING CHECKLIST
═══════════════════════════════════════════════════════════════════════════════

Before finalizing the plan, verify:

LAYER 2 - FIELD SPECIFICATIONS:
[ ] <entity_specs> section with ALL entities and their EXACT fields
[ ] BACKEND_FIELDS and FRONTEND_FIELDS defined for each entity
[ ] Each file description includes FIELDS list
[ ] Service description includes convertToDto field mappings
[ ] Controller description includes exact method signatures
[ ] Field names CONSISTENT across Entity/DTO/Service/Frontend types

SECURITY & LOMBOK (STUDENT PROJECTS):
[ ] NO spring-boot-starter-security in pom.xml
[ ] NO SecurityConfig.java, NO JWT files
[ ] NO Lombok in pom.xml

BACKEND:
[ ] Backend entity has all fields with explicit getters/setters
[ ] Backend DTO matches entity for API responses
[ ] CorsConfig.java is included (CORS only, not security)
[ ] Enums are separate files in model/enums/

FRONTEND:
[ ] Frontend types/index.ts matches backend DTO property names EXACTLY
[ ] PageResponse<T> uses: content, totalElements, number (Spring Boot format)
[ ] vite-env.d.ts is included in files list
[ ] vite.config.ts has proxy configuration

DOCKER:
[ ] Dockerfile uses apk (not apt-get) for Alpine images
[ ] docker-compose.yml connects frontend to backend
