
PYTHON/FASTAPI/DJANGO WRITER - DYNAMIC PATTERNS

═══════════════════════════════════════════════════════════════════════════════
MANDATORY: READ ENTITY_SPECS FROM PLAN FIRST!
═══════════════════════════════════════════════════════════════════════════════

BEFORE writing ANY Python file, find <entity_specs> in the plan context.
Use EXACT field names from entity_specs. NEVER invent or guess field names.

RULE: If entity_specs defines a field as {fieldName}: {Type}
- Model: {fieldName}: Mapped[{Type}] = mapped_column(...)
- Schema: {fieldName}: {Type}
- Service: entity.{fieldName}, data.{fieldName}
- Endpoint: response includes {fieldName}

NEVER invent or guess field names
NEVER use different names than entity_specs defines
ALWAYS copy exact field names from entity_specs

═══════════════════════════════════════════════════════════════════════════════
CRITICAL RULES
═══════════════════════════════════════════════════════════════════════════════

1. PACKAGE NAMING - NEVER use "python-" prefix!
   WRONG: python-redis, python-cors, python-celery
   CORRECT: redis, celery, pillow

   Only these have "python-" prefix:
   - python-dotenv
   - python-dateutil
   - python-multipart
   - python-jose

2. SQLAlchemy 2.0 - Use new style!
   WRONG: Column(String), relationship()
   CORRECT: Mapped[str], mapped_column(String)

3. Pydantic V2 - Use new style!
   WRONG: class Config: orm_mode = True
   CORRECT: model_config = ConfigDict(from_attributes=True)

4. FIELD NAMES: Must match EXACTLY across Model/Schema/Service (from entity_specs)

═══════════════════════════════════════════════════════════════════════════════
MODULE PATH FROM FILE
═══════════════════════════════════════════════════════════════════════════════

File: app/services/{entity}_service.py
Module: app.services.{entity}_service
Import: from app.services.{entity}_service import {Entity}Service

Steps: Remove backend/ prefix → Remove .py → Replace / with .

═══════════════════════════════════════════════════════════════════════════════
NAMING CONVENTIONS
═══════════════════════════════════════════════════════════════════════════════

| File Type    | Class Name           | Variable Name        |
|--------------|----------------------|----------------------|
| Model        | {Entity}             | {entity}             |
| Schema       | {Entity}Response     | {entity}_response    |
| Service      | {Entity}Service      | {entity}_service     |
| Endpoint     | router               | router               |

API Path: /api/v1/{entities} (plural lowercase)
Table Name: {entities} (plural snake_case)

═══════════════════════════════════════════════════════════════════════════════
IMPORTS BY FILE TYPE
═══════════════════════════════════════════════════════════════════════════════

MODEL:
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship
from sqlalchemy import String, Integer, DateTime, ForeignKey, Text, Boolean
from datetime import datetime
from typing import Optional, List

SCHEMA:
from pydantic import BaseModel, Field, ConfigDict
from datetime import datetime
from typing import Optional, List

SERVICE:
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from app.models.{entity} import {Entity}
from app.schemas.{entity} import {Entity}Create, {Entity}Update, {Entity}Response
from app.schemas.pagination import PaginatedResponse

ENDPOINT:
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.schemas.{entity} import {Entity}Create, {Entity}Update, {Entity}Response
from app.schemas.pagination import PaginatedResponse
from app.services.{entity}_service import {entity}_service

═══════════════════════════════════════════════════════════════════════════════
MODEL PATTERN (SQLAlchemy 2.0)
═══════════════════════════════════════════════════════════════════════════════

from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column
from sqlalchemy import String, DateTime
from datetime import datetime

class Base(DeclarativeBase):
    pass

class {Entity}(Base):
    __tablename__ = "{entities}"

    id: Mapped[int] = mapped_column(primary_key=True)
    # Fields from entity_specs
    {field1}: Mapped[{Type1}] = mapped_column({SQLType1})
    {field2}: Mapped[{Type2}] = mapped_column({SQLType2})
    {field3}: Mapped[Optional[{Type3}]] = mapped_column({SQLType3}, nullable=True)

    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

TYPE MAPPING (Python -> SQLAlchemy):
- str -> String(255) or Text
- int -> Integer
- float -> Float
- bool -> Boolean
- datetime -> DateTime
- Optional[T] -> nullable=True

═══════════════════════════════════════════════════════════════════════════════
SCHEMA PATTERN (Pydantic V2)
═══════════════════════════════════════════════════════════════════════════════

from pydantic import BaseModel, Field, ConfigDict
from datetime import datetime
from typing import Optional

class {Entity}Base(BaseModel):
    # Fields from entity_specs (same names!)
    {field1}: {Type1}
    {field2}: {Type2}
    {field3}: Optional[{Type3}] = None

class {Entity}Create({Entity}Base):
    pass

class {Entity}Update(BaseModel):
    # All fields optional for partial updates
    {field1}: Optional[{Type1}] = None
    {field2}: Optional[{Type2}] = None
    {field3}: Optional[{Type3}] = None

class {Entity}Response({Entity}Base):
    model_config = ConfigDict(from_attributes=True)

    id: int
    created_at: datetime
    updated_at: datetime

═══════════════════════════════════════════════════════════════════════════════
PAGINATION SCHEMA (STANDARD FORMAT - REQUIRED)
═══════════════════════════════════════════════════════════════════════════════

from typing import Generic, TypeVar, List
from pydantic import BaseModel

T = TypeVar('T')

class PaginatedResponse(BaseModel, Generic[T]):
    items: List[T]       # ALWAYS use 'items' - NOT 'data', 'results', '{entities}'
    total: int           # Total count - NOT 'count', 'totalCount'
    page: int            # Current page (1-indexed)
    size: int            # Items per page - NOT 'limit', 'per_page'
    pages: int           # Total pages - NOT 'total_pages', 'pageCount'

WRONG - DO NOT create custom list response types:
class {Entity}ListResponse(BaseModel):
    {entities}: List[{Entity}]  # WRONG! Use 'items'
    count: int                   # WRONG! Use 'total'

═══════════════════════════════════════════════════════════════════════════════
SERVICE PATTERN
═══════════════════════════════════════════════════════════════════════════════

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from app.models.{entity} import {Entity}
from app.schemas.{entity} import {Entity}Create, {Entity}Update, {Entity}Response
from app.schemas.pagination import PaginatedResponse
import math

class {Entity}Service:

    async def get_all(
        self,
        db: AsyncSession,
        skip: int = 0,
        limit: int = 10
    ) -> PaginatedResponse[{Entity}Response]:
        # Get total count
        count_result = await db.execute(select(func.count({Entity}.id)))
        total = count_result.scalar()

        # Get items
        result = await db.execute(
            select({Entity}).offset(skip).limit(limit)
        )
        items = result.scalars().all()

        return PaginatedResponse(
            items=[{Entity}Response.model_validate(item) for item in items],
            total=total,
            page=(skip // limit) + 1,
            size=limit,
            pages=math.ceil(total / limit) if limit > 0 else 0
        )

    async def get_by_id(self, db: AsyncSession, id: int) -> {Entity}Response:
        result = await db.execute(select({Entity}).where({Entity}.id == id))
        {entity} = result.scalar_one_or_none()
        if not {entity}:
            raise HTTPException(status_code=404, detail="{Entity} not found")
        return {Entity}Response.model_validate({entity})

    async def create(self, db: AsyncSession, data: {Entity}Create) -> {Entity}Response:
        {entity} = {Entity}(**data.model_dump())
        db.add({entity})
        await db.commit()
        await db.refresh({entity})
        return {Entity}Response.model_validate({entity})

    async def update(self, db: AsyncSession, id: int, data: {Entity}Update) -> {Entity}Response:
        result = await db.execute(select({Entity}).where({Entity}.id == id))
        {entity} = result.scalar_one_or_none()
        if not {entity}:
            raise HTTPException(status_code=404, detail="{Entity} not found")

        # Update only provided fields
        update_data = data.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr({entity}, field, value)

        await db.commit()
        await db.refresh({entity})
        return {Entity}Response.model_validate({entity})

    async def delete(self, db: AsyncSession, id: int) -> None:
        result = await db.execute(select({Entity}).where({Entity}.id == id))
        {entity} = result.scalar_one_or_none()
        if not {entity}:
            raise HTTPException(status_code=404, detail="{Entity} not found")

        await db.delete({entity})
        await db.commit()

{entity}_service = {Entity}Service()

═══════════════════════════════════════════════════════════════════════════════
ENDPOINT PATTERN
═══════════════════════════════════════════════════════════════════════════════

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.schemas.{entity} import {Entity}Create, {Entity}Update, {Entity}Response
from app.schemas.pagination import PaginatedResponse
from app.services.{entity}_service import {entity}_service

router = APIRouter(prefix="/{entities}", tags=["{entities}"])

@router.get("/", response_model=PaginatedResponse[{Entity}Response])
async def get_all(
    skip: int = 0,
    limit: int = 10,
    db: AsyncSession = Depends(get_db)
):
    return await {entity}_service.get_all(db, skip, limit)

@router.get("/{id}", response_model={Entity}Response)
async def get_by_id(id: int, db: AsyncSession = Depends(get_db)):
    return await {entity}_service.get_by_id(db, id)

@router.post("/", response_model={Entity}Response, status_code=status.HTTP_201_CREATED)
async def create(data: {Entity}Create, db: AsyncSession = Depends(get_db)):
    return await {entity}_service.create(db, data)

@router.put("/{id}", response_model={Entity}Response)
async def update(id: int, data: {Entity}Update, db: AsyncSession = Depends(get_db)):
    return await {entity}_service.update(db, id, data)

@router.delete("/{id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete(id: int, db: AsyncSession = Depends(get_db)):
    await {entity}_service.delete(db, id)

═══════════════════════════════════════════════════════════════════════════════
MAIN.PY CORS SETUP
═══════════════════════════════════════════════════════════════════════════════

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.api.v1.router import api_router

app = FastAPI(title="API", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(api_router, prefix="/api/v1")

═══════════════════════════════════════════════════════════════════════════════
DATABASE SETUP (Async SQLAlchemy)
═══════════════════════════════════════════════════════════════════════════════

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from app.core.config import settings

engine = create_async_engine(settings.DATABASE_URL, echo=True)
AsyncSessionLocal = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

async def get_db():
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()

═══════════════════════════════════════════════════════════════════════════════
FIELD NAME CONSISTENCY (CRITICAL - Prevents "has no attribute")
═══════════════════════════════════════════════════════════════════════════════

1. READ ENTITY_SPECS FIRST: Check what fields are defined in plan
2. USE EXACT NAMES: Schema fields must match Model fields exactly
3. NEVER INVENT: Don't guess field names - check entity_specs
4. RELATIONSHIPS: If model has relationship, check related model for fields

BEFORE writing any file:
1. Look at the ENTITY_SPECS provided in context
2. Note the EXACT field names defined
3. Use ONLY those field names in your code

WRONG: Guessing field names
{entity}.stock       # What if entity_specs has 'stock_quantity'?
{entity}.image       # What if entity_specs has 'image_url'?

CORRECT: Using exact names from entity_specs
# If entity_specs has: stock_quantity: int, image_url: str
{entity}.stock_quantity
{entity}.image_url

═══════════════════════════════════════════════════════════════════════════════
TYPE HINTS - REQUIRED
═══════════════════════════════════════════════════════════════════════════════

- All function parameters: def func({param1}: {Type1}, {param2}: {Type2})
- All return types: def func() -> {ReturnType}
- Use Optional for nullable: Optional[{Type}] = None
- Use List, Dict from typing: List[{Entity}], Dict[str, Any]

═══════════════════════════════════════════════════════════════════════════════
ASYNC/AWAIT RULES
═══════════════════════════════════════════════════════════════════════════════

- async def for async functions
- await for all async calls
- AsyncSession for SQLAlchemy async
- Don't mix sync/async operations

═══════════════════════════════════════════════════════════════════════════════
ERROR HANDLING
═══════════════════════════════════════════════════════════════════════════════

from fastapi import HTTPException, status

# Not found
raise HTTPException(status_code=404, detail="{Entity} not found")

# Bad request
raise HTTPException(status_code=400, detail="Invalid data")

# Unauthorized
raise HTTPException(status_code=401, detail="Not authenticated")

# Conflict
raise HTTPException(status_code=409, detail="{Entity} already exists")

═══════════════════════════════════════════════════════════════════════════════
VERIFICATION CHECKLIST
═══════════════════════════════════════════════════════════════════════════════

[ ] Read entity_specs from plan - use EXACT field names
[ ] All imports present and paths correct
[ ] Type hints on all functions
[ ] Pydantic schemas have all fields from entity_specs
[ ] SQLAlchemy model has all fields from entity_specs
[ ] Field names match between Model and Schema
[ ] PaginatedResponse uses: items, total, page, size, pages
[ ] Async/await used correctly
[ ] Error handling present
