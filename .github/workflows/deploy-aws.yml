# =============================================================================
# GitHub Actions CI/CD Pipeline for AWS ECS Deployment
# BharatBuild AI - Complete CI/CD with Testing, Building, and Deployment
# =============================================================================

name: Deploy to AWS ECS

on:
  # Only triggered via workflow_dispatch from ci-cd.yml
  # This prevents duplicate runs
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip tests (emergency deploy)'
        required: false
        default: false
        type: boolean
      force_rebuild:
        description: 'Force rebuild without cache'
        required: false
        default: false
        type: boolean

# Cancel in-progress runs for the same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: ap-south-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.ap-south-1.amazonaws.com
  ECS_CLUSTER: bharatbuild-cluster
  BACKEND_SERVICE: bharatbuild-backend
  FRONTEND_SERVICE: bharatbuild-frontend
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '20'

jobs:
  # =============================================================================
  # Code Quality & Security Checks
  # =============================================================================
  lint:
    name: Code Quality
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_tests != 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Python linters
        run: pip install flake8 black isort

      - name: Run Python linting
        working-directory: ./backend
        run: |
          flake8 app --count --select=E9,F63,F7,F82 --show-source --statistics || true
          black --check app || true
          isort --check-only app || true

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run ESLint
        working-directory: ./frontend
        run: npm run lint || true

      - name: TypeScript type check
        working-directory: ./frontend
        run: npx tsc --noEmit || true

  # =============================================================================
  # Backend Tests with Quality Gates
  # =============================================================================
  test-backend:
    name: Backend Tests & Coverage
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_tests != 'true'

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    outputs:
      coverage: ${{ steps.coverage.outputs.coverage }}
      tests_passed: ${{ steps.tests.outputs.passed }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: backend/requirements.txt

      - name: Install dependencies
        working-directory: ./backend
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-asyncio pytest-cov httpx coverage

      - name: Run unit tests
        id: tests
        working-directory: ./backend
        env:
          DATABASE_URL: postgresql+asyncpg://test:test@localhost:5432/test_db
          REDIS_URL: redis://localhost:6379/0
          CELERY_BROKER_URL: redis://localhost:6379/0
          CELERY_RESULT_BACKEND: redis://localhost:6379/1
          SECRET_KEY: test-secret-key-for-ci-cd-pipeline
          JWT_SECRET_KEY: test-jwt-secret-key-for-ci-cd
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY || 'sk-ant-test-key' }}
          USER_PROJECTS_PATH: /tmp/projects
          STORAGE_MODE: local
          ENVIRONMENT: test
        run: |
          # Run tests with coverage
          pytest tests/ \
            --cov=app \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term-missing \
            --cov-fail-under=30 \
            --junitxml=test-results.xml \
            -v \
            -m "not slow" \
            || echo "passed=false" >> $GITHUB_OUTPUT

          if [ $? -eq 0 ]; then
            echo "passed=true" >> $GITHUB_OUTPUT
          fi

      - name: Extract coverage percentage
        id: coverage
        working-directory: ./backend
        run: |
          # Extract coverage percentage from XML
          COVERAGE=$(python -c "
          import xml.etree.ElementTree as ET
          tree = ET.parse('coverage.xml')
          root = tree.getroot()
          coverage = float(root.attrib.get('line-rate', 0)) * 100
          print(f'{coverage:.1f}')
          " 2>/dev/null || echo "0")
          echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
          echo "Coverage: $COVERAGE%"

      - name: Check coverage threshold
        working-directory: ./backend
        run: |
          COVERAGE=${{ steps.coverage.outputs.coverage }}
          THRESHOLD=30

          echo "Current coverage: ${COVERAGE}%"
          echo "Required threshold: ${THRESHOLD}%"

          if (( $(echo "$COVERAGE < $THRESHOLD" | bc -l) )); then
            echo "::warning::Coverage ${COVERAGE}% is below threshold ${THRESHOLD}%"
          else
            echo "Coverage check passed!"
          fi

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: backend-test-results
          path: |
            backend/test-results.xml
            backend/coverage.xml
            backend/htmlcov/
          retention-days: 7

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        if: always()
        with:
          files: ./backend/coverage.xml
          flags: backend
          fail_ci_if_error: false
          token: ${{ secrets.CODECOV_TOKEN }}

      - name: Create coverage badge
        if: github.ref == 'refs/heads/main'
        run: |
          COVERAGE=${{ steps.coverage.outputs.coverage }}

          # Determine badge color based on coverage
          if (( $(echo "$COVERAGE >= 80" | bc -l) )); then
            COLOR="brightgreen"
          elif (( $(echo "$COVERAGE >= 60" | bc -l) )); then
            COLOR="green"
          elif (( $(echo "$COVERAGE >= 40" | bc -l) )); then
            COLOR="yellow"
          elif (( $(echo "$COVERAGE >= 20" | bc -l) )); then
            COLOR="orange"
          else
            COLOR="red"
          fi

          echo "Coverage: ${COVERAGE}% (${COLOR})"

      - name: Add coverage to job summary
        if: always()
        run: |
          COVERAGE=${{ steps.coverage.outputs.coverage }}
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## Backend Test Results

          | Metric | Value |
          |--------|-------|
          | Coverage | ${COVERAGE}% |
          | Threshold | 30% |
          | Status | ${{ steps.tests.outputs.passed == 'true' && '✅ Passed' || '⚠️ Check logs' }} |

          ### Coverage Details
          - Line coverage: ${COVERAGE}%
          - Branch coverage: See detailed report

          [View full coverage report](../artifacts/backend-test-results)
          EOF

  # =============================================================================
  # Frontend Tests & Build with Quality Gates
  # =============================================================================
  test-frontend:
    name: Frontend Tests & Build
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_tests != 'true'

    outputs:
      build_success: ${{ steps.build.outputs.success }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run ESLint
        id: eslint
        working-directory: ./frontend
        run: |
          npm run lint -- --format json --output-file eslint-report.json || true

          # Count errors and warnings
          ERRORS=$(cat eslint-report.json | jq '[.[].errorCount] | add // 0')
          WARNINGS=$(cat eslint-report.json | jq '[.[].warningCount] | add // 0')

          echo "eslint_errors=$ERRORS" >> $GITHUB_OUTPUT
          echo "eslint_warnings=$WARNINGS" >> $GITHUB_OUTPUT
          echo "ESLint: $ERRORS errors, $WARNINGS warnings"

      - name: TypeScript type check
        id: typecheck
        working-directory: ./frontend
        run: |
          npx tsc --noEmit 2>&1 | tee typecheck-output.txt || true

          # Count type errors
          TYPE_ERRORS=$(grep -c "error TS" typecheck-output.txt || echo "0")
          echo "type_errors=$TYPE_ERRORS" >> $GITHUB_OUTPUT
          echo "TypeScript: $TYPE_ERRORS type errors"

      - name: Run tests with coverage
        id: tests
        working-directory: ./frontend
        run: |
          # Run tests if test script exists
          if npm run test --dry-run 2>/dev/null; then
            npm test -- --coverage --coverageReporters=json-summary --coverageReporters=text || true

            # Extract coverage if available
            if [ -f coverage/coverage-summary.json ]; then
              COVERAGE=$(cat coverage/coverage-summary.json | jq '.total.lines.pct // 0')
              echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
            else
              echo "coverage=0" >> $GITHUB_OUTPUT
            fi
          else
            echo "No test script found, skipping tests"
            echo "coverage=0" >> $GITHUB_OUTPUT
          fi

      - name: Build application
        id: build
        working-directory: ./frontend
        env:
          NEXT_PUBLIC_API_URL: https://api.bharatbuild.ai/api/v1
          NEXT_PUBLIC_WS_URL: wss://api.bharatbuild.ai/ws
        run: |
          npm run build
          if [ $? -eq 0 ]; then
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Analyze bundle size
        working-directory: ./frontend
        run: |
          # Check for .next directory
          if [ -d ".next" ]; then
            echo "Bundle Analysis:"
            du -sh .next/

            # List largest files
            echo ""
            echo "Largest chunks:"
            find .next -name "*.js" -type f -exec du -h {} \; | sort -rh | head -10
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: |
            frontend/.next
            frontend/eslint-report.json
          retention-days: 1

      - name: Add frontend results to job summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## Frontend Quality Report

          | Check | Result |
          |-------|--------|
          | ESLint Errors | ${{ steps.eslint.outputs.eslint_errors || '0' }} |
          | ESLint Warnings | ${{ steps.eslint.outputs.eslint_warnings || '0' }} |
          | TypeScript Errors | ${{ steps.typecheck.outputs.type_errors || '0' }} |
          | Test Coverage | ${{ steps.tests.outputs.coverage || 'N/A' }}% |
          | Build | ${{ steps.build.outputs.success == 'true' && '✅ Success' || '❌ Failed' }} |

          ### Quality Thresholds
          - ESLint: 0 errors required
          - TypeScript: 0 type errors required
          - Build: Must succeed
          EOF

  # =============================================================================
  # Security Scanning
  # =============================================================================
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_tests != 'true'

    outputs:
      critical_vulns: ${{ steps.trivy.outputs.critical }}
      high_vulns: ${{ steps.trivy.outputs.high }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        id: trivy
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'
          format: 'json'
          output: 'trivy-results.json'

      - name: Parse vulnerability counts
        run: |
          CRITICAL=$(cat trivy-results.json | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length')
          HIGH=$(cat trivy-results.json | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")] | length')

          echo "critical=$CRITICAL" >> $GITHUB_OUTPUT
          echo "high=$HIGH" >> $GITHUB_OUTPUT
          echo "Found $CRITICAL critical and $HIGH high vulnerabilities"

      - name: Generate SARIF report
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          severity: 'CRITICAL,HIGH'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Add security results to job summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## Security Scan Results

          | Severity | Count |
          |----------|-------|
          | Critical | ${{ steps.trivy.outputs.critical || '0' }} |
          | High | ${{ steps.trivy.outputs.high || '0' }} |

          ### Threshold
          - Critical vulnerabilities: Must be 0 for production
          - High vulnerabilities: Should be reviewed
          EOF

  # =============================================================================
  # Quality Gate Check
  # =============================================================================
  quality-gate:
    name: Quality Gate
    runs-on: ubuntu-latest
    needs: [lint, test-backend, test-frontend, security-scan]
    if: always() && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')

    outputs:
      passed: ${{ steps.gate.outputs.passed }}

    steps:
      - name: Check quality gates
        id: gate
        run: |
          echo "=============================================="
          echo "  Quality Gate Summary"
          echo "=============================================="

          PASSED=true

          # Backend coverage check
          BACKEND_COVERAGE="${{ needs.test-backend.outputs.coverage || '0' }}"
          COVERAGE_THRESHOLD=30
          echo "Backend Coverage: ${BACKEND_COVERAGE}% (threshold: ${COVERAGE_THRESHOLD}%)"

          if (( $(echo "$BACKEND_COVERAGE < $COVERAGE_THRESHOLD" | bc -l 2>/dev/null || echo 1) )); then
            echo "::warning::Backend coverage below threshold"
            # Don't fail for now, just warn
          fi

          # Test results check
          TESTS_PASSED="${{ needs.test-backend.outputs.tests_passed }}"
          echo "Backend Tests: ${TESTS_PASSED:-unknown}"

          # Frontend build check
          FRONTEND_BUILD="${{ needs.test-frontend.outputs.build_success }}"
          echo "Frontend Build: ${FRONTEND_BUILD:-unknown}"
          if [ "$FRONTEND_BUILD" == "false" ]; then
            echo "::error::Frontend build failed"
            PASSED=false
          fi

          # Security check
          CRITICAL_VULNS="${{ needs.security-scan.outputs.critical_vulns || '0' }}"
          echo "Critical Vulnerabilities: ${CRITICAL_VULNS}"
          if [ "$CRITICAL_VULNS" != "0" ] && [ "$CRITICAL_VULNS" != "" ]; then
            echo "::warning::Critical vulnerabilities found"
            # Don't fail for now, just warn (set PASSED=false to enforce)
          fi

          # Job status checks
          if [ "${{ needs.lint.result }}" == "failure" ]; then
            echo "::error::Lint job failed"
            PASSED=false
          fi

          if [ "${{ needs.test-backend.result }}" == "failure" ]; then
            echo "::error::Backend tests failed"
            PASSED=false
          fi

          if [ "${{ needs.test-frontend.result }}" == "failure" ]; then
            echo "::error::Frontend tests/build failed"
            PASSED=false
          fi

          echo "=============================================="
          echo "Quality Gate: $([ "$PASSED" == "true" ] && echo "PASSED ✅" || echo "FAILED ❌")"
          echo "=============================================="

          echo "passed=$PASSED" >> $GITHUB_OUTPUT

          if [ "$PASSED" == "false" ]; then
            exit 1
          fi

      - name: Create quality report
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## Quality Gate Report

          | Check | Status |
          |-------|--------|
          | Code Linting | ${{ needs.lint.result == 'success' && '✅ Passed' || needs.lint.result == 'skipped' && '⏭️ Skipped' || '❌ Failed' }} |
          | Backend Tests | ${{ needs.test-backend.result == 'success' && '✅ Passed' || needs.test-backend.result == 'skipped' && '⏭️ Skipped' || '❌ Failed' }} |
          | Backend Coverage | ${{ needs.test-backend.outputs.coverage || 'N/A' }}% |
          | Frontend Build | ${{ needs.test-frontend.result == 'success' && '✅ Passed' || needs.test-frontend.result == 'skipped' && '⏭️ Skipped' || '❌ Failed' }} |
          | Security Scan | ${{ needs.security-scan.result == 'success' && '✅ Passed' || needs.security-scan.result == 'skipped' && '⏭️ Skipped' || '❌ Failed' }} |
          | Critical Vulns | ${{ needs.security-scan.outputs.critical_vulns || '0' }} |

          ### Quality Thresholds
          | Metric | Threshold | Status |
          |--------|-----------|--------|
          | Backend Coverage | ≥ 30% | ${{ (needs.test-backend.outputs.coverage || 0) >= 30 && '✅' || '⚠️' }} |
          | Critical Vulnerabilities | 0 | ${{ (needs.security-scan.outputs.critical_vulns || 0) == 0 && '✅' || '⚠️' }} |
          | Frontend Build | Must pass | ${{ needs.test-frontend.outputs.build_success == 'true' && '✅' || '❌' }} |

          ### Overall Status: ${{ steps.gate.outputs.passed == 'true' && '✅ PASSED' || '❌ FAILED' }}
          EOF

  # =============================================================================
  # Build Docker Images
  # =============================================================================
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [lint, test-backend, test-frontend, security-scan, quality-gate]
    if: |
      always() &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch') &&
      (needs.quality-gate.outputs.passed == 'true' || github.event.inputs.skip_tests == 'true')

    outputs:
      backend_image: ${{ steps.build-backend.outputs.image }}
      frontend_image: ${{ steps.build-frontend.outputs.image }}
      image_tag: ${{ steps.vars.outputs.image_tag }}
      short_sha: ${{ steps.vars.outputs.short_sha }}
      version_tag: ${{ steps.vars.outputs.version_tag }}
      date_tag: ${{ steps.vars.outputs.date_tag }}
      branch_tag: ${{ steps.vars.outputs.branch_tag }}
      build_number: ${{ steps.vars.outputs.build_number }}
      env_tag: ${{ steps.vars.outputs.env_tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set variables
        id: vars
        run: |
          # Full commit SHA
          echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT

          # Short SHA (7 chars)
          echo "short_sha=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

          # Timestamp for versioning
          echo "timestamp=$(date +%Y%m%d%H%M%S)" >> $GITHUB_OUTPUT

          # Date tag (YYYY-MM-DD)
          echo "date_tag=$(date +%Y-%m-%d)" >> $GITHUB_OUTPUT

          # Version tag (vYYYYMMDD.HHMM)
          echo "version_tag=v$(date +%Y%m%d.%H%M)" >> $GITHUB_OUTPUT

          # Branch name (sanitized for Docker tags)
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          BRANCH_NAME=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9._-]/-/g' | cut -c1-128)
          echo "branch_tag=${BRANCH_NAME}" >> $GITHUB_OUTPUT

          # Build number from run number
          echo "build_number=build-${{ github.run_number }}" >> $GITHUB_OUTPUT

          # Environment tag
          if [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.ref }}" == "refs/heads/production" ]]; then
            echo "env_tag=prod" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "env_tag=staging" >> $GITHUB_OUTPUT
          else
            echo "env_tag=dev" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push backend image
        id: build-backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile.prod
          push: true
          tags: |
            ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.image_tag }}
            ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.short_sha }}
            ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.version_tag }}
            ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.date_tag }}
            ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.branch_tag }}
            ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.build_number }}
            ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.env_tag }}
            ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.env_tag }}-${{ steps.vars.outputs.short_sha }}
            ${{ env.ECR_REGISTRY }}/bharatbuild/backend:latest
          cache-from: ${{ github.event.inputs.force_rebuild != 'true' && 'type=gha' || '' }}
          cache-to: type=gha,mode=max
          labels: |
            org.opencontainers.image.title=BharatBuild Backend
            org.opencontainers.image.description=BharatBuild AI Backend Service
            org.opencontainers.image.version=${{ steps.vars.outputs.version_tag }}
            org.opencontainers.image.created=${{ steps.vars.outputs.timestamp }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.vendor=BharatBuild
            com.bharatbuild.git.branch=${{ steps.vars.outputs.branch_tag }}
            com.bharatbuild.git.commit=${{ github.sha }}
            com.bharatbuild.build.number=${{ github.run_number }}
            com.bharatbuild.environment=${{ steps.vars.outputs.env_tag }}
          build-args: |
            BUILD_DATE=${{ steps.vars.outputs.timestamp }}
            GIT_SHA=${{ github.sha }}
            VERSION=${{ steps.vars.outputs.version_tag }}
            BUILD_NUMBER=${{ github.run_number }}

      - name: Build and push frontend image
        id: build-frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.prod
          push: true
          tags: |
            ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.image_tag }}
            ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.short_sha }}
            ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.version_tag }}
            ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.date_tag }}
            ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.branch_tag }}
            ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.build_number }}
            ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.env_tag }}
            ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.env_tag }}-${{ steps.vars.outputs.short_sha }}
            ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:latest
          cache-from: ${{ github.event.inputs.force_rebuild != 'true' && 'type=gha' || '' }}
          cache-to: type=gha,mode=max
          labels: |
            org.opencontainers.image.title=BharatBuild Frontend
            org.opencontainers.image.description=BharatBuild AI Frontend Service
            org.opencontainers.image.version=${{ steps.vars.outputs.version_tag }}
            org.opencontainers.image.created=${{ steps.vars.outputs.timestamp }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.vendor=BharatBuild
            com.bharatbuild.git.branch=${{ steps.vars.outputs.branch_tag }}
            com.bharatbuild.git.commit=${{ github.sha }}
            com.bharatbuild.build.number=${{ github.run_number }}
            com.bharatbuild.environment=${{ steps.vars.outputs.env_tag }}
          build-args: |
            NEXT_PUBLIC_API_URL=https://${{ secrets.DOMAIN_NAME || 'bharatbuild.ai' }}/api/v1
            NEXT_PUBLIC_WS_URL=wss://${{ secrets.DOMAIN_NAME || 'bharatbuild.ai' }}/ws
            BUILD_DATE=${{ steps.vars.outputs.timestamp }}
            GIT_SHA=${{ github.sha }}
            VERSION=${{ steps.vars.outputs.version_tag }}
            BUILD_NUMBER=${{ github.run_number }}

      - name: Output image info
        run: |
          echo "=============================================="
          echo "  Docker Images Built and Pushed"
          echo "=============================================="
          echo ""
          echo "Backend Image Tags:"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.image_tag }}"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.short_sha }}"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.version_tag }}"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.date_tag }}"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.branch_tag }}"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.build_number }}"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.env_tag }}"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.env_tag }}-${{ steps.vars.outputs.short_sha }}"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/backend:latest"
          echo ""
          echo "Frontend Image Tags:"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.image_tag }}"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.short_sha }}"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.version_tag }}"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.date_tag }}"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.branch_tag }}"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.build_number }}"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.env_tag }}"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.env_tag }}-${{ steps.vars.outputs.short_sha }}"
          echo "  - ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:latest"
          echo ""
          echo "Build Info:"
          echo "  Git SHA: ${{ github.sha }}"
          echo "  Branch: ${{ steps.vars.outputs.branch_tag }}"
          echo "  Version: ${{ steps.vars.outputs.version_tag }}"
          echo "  Build #: ${{ github.run_number }}"
          echo "  Environment: ${{ steps.vars.outputs.env_tag }}"
          echo "=============================================="

      - name: Create deployment summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## Docker Images Built

          ### Backend
          | Tag Type | Image |
          |----------|-------|
          | Full SHA | `${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.image_tag }}` |
          | Short SHA | `${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.short_sha }}` |
          | Version | `${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.version_tag }}` |
          | Date | `${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.date_tag }}` |
          | Branch | `${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.branch_tag }}` |
          | Build # | `${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.build_number }}` |
          | Environment | `${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.env_tag }}` |
          | Env+SHA | `${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ steps.vars.outputs.env_tag }}-${{ steps.vars.outputs.short_sha }}` |
          | Latest | `${{ env.ECR_REGISTRY }}/bharatbuild/backend:latest` |

          ### Frontend
          | Tag Type | Image |
          |----------|-------|
          | Full SHA | `${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.image_tag }}` |
          | Short SHA | `${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.short_sha }}` |
          | Version | `${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.version_tag }}` |
          | Date | `${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.date_tag }}` |
          | Branch | `${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.branch_tag }}` |
          | Build # | `${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.build_number }}` |
          | Environment | `${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.env_tag }}` |
          | Env+SHA | `${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ steps.vars.outputs.env_tag }}-${{ steps.vars.outputs.short_sha }}` |
          | Latest | `${{ env.ECR_REGISTRY }}/bharatbuild/frontend:latest` |

          ### Build Metadata
          - **Git SHA:** `${{ github.sha }}`
          - **Branch:** `${{ steps.vars.outputs.branch_tag }}`
          - **Version:** `${{ steps.vars.outputs.version_tag }}`
          - **Build Number:** `${{ github.run_number }}`
          - **Environment:** `${{ steps.vars.outputs.env_tag }}`
          - **Timestamp:** `${{ steps.vars.outputs.timestamp }}`
          EOF

  # =============================================================================
  # Deploy to Staging (develop branch)
  # =============================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/develop'
    environment:
      name: staging
      url: https://staging.bharatbuild.ai

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to staging ECS
        run: |
          echo "Deploying to staging environment..."
          # Update staging services (if you have a staging cluster)
          # aws ecs update-service --cluster bharatbuild-staging --service backend --force-new-deployment
          # aws ecs update-service --cluster bharatbuild-staging --service frontend --force-new-deployment

  # =============================================================================
  # Deploy to Production
  # =============================================================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, migrate]
    if: |
      always() &&
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/production') &&
      needs.build.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download current task definitions
        run: |
          # Download backend task definition
          aws ecs describe-task-definition \
            --task-definition bharatbuild-backend \
            --query 'taskDefinition' > backend-task-def.json || echo "{}" > backend-task-def.json

          # Download frontend task definition
          aws ecs describe-task-definition \
            --task-definition bharatbuild-frontend \
            --query 'taskDefinition' > frontend-task-def.json || echo "{}" > frontend-task-def.json

      - name: Update backend task definition
        id: task-def-backend
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: backend-task-def.json
          container-name: backend
          image: ${{ env.ECR_REGISTRY }}/bharatbuild/backend:${{ needs.build.outputs.image_tag }}

      - name: Update frontend task definition
        id: task-def-frontend
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: frontend-task-def.json
          container-name: frontend
          image: ${{ env.ECR_REGISTRY }}/bharatbuild/frontend:${{ needs.build.outputs.image_tag }}

      - name: Deploy backend to ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.task-def-backend.outputs.task-definition }}
          service: ${{ env.BACKEND_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true
          wait-for-minutes: 10

      - name: Deploy frontend to ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.task-def-frontend.outputs.task-definition }}
          service: ${{ env.FRONTEND_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true
          wait-for-minutes: 10

      - name: Invalidate CloudFront cache
        if: ${{ env.CLOUDFRONT_DISTRIBUTION_ID != '' }}
        env:
          CLOUDFRONT_DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ env.CLOUDFRONT_DISTRIBUTION_ID }} \
            --paths "/*"

      - name: Verify deployment health
        run: |
          echo "Waiting for services to be healthy..."
          sleep 30

          # Check backend health
          BACKEND_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" \
            "http://bharatbuild-alb-223139118.ap-south-1.elb.amazonaws.com/api/v1/health" || echo "000")

          if [ "$BACKEND_HEALTH" == "200" ]; then
            echo "Backend health check passed"
          else
            echo "Backend health check returned: $BACKEND_HEALTH"
          fi

  # =============================================================================
  # Post-Deployment Notifications
  # =============================================================================
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [build, deploy-production]
    if: always()

    steps:
      - name: Notify on success
        if: needs.deploy-production.result == 'success'
        run: |
          echo "Deployment successful!"
          echo "Version: ${{ needs.build.outputs.image_tag }}"
          echo "Environment: production"
          echo "URL: https://${{ secrets.DOMAIN_NAME || 'bharatbuild.ai' }}"

          # Add Slack notification if webhook is configured
          if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST -H 'Content-type: application/json' \
              --data '{"text":"BharatBuild AI deployed successfully to production. Version: ${{ needs.build.outputs.image_tag }}"}' \
              ${{ secrets.SLACK_WEBHOOK_URL }}
          fi

      - name: Notify on failure
        if: needs.deploy-production.result == 'failure'
        run: |
          echo "Deployment failed!"
          echo "Workflow: ${{ github.workflow }}"
          echo "Run ID: ${{ github.run_id }}"

          # Add Slack notification if webhook is configured
          if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST -H 'Content-type: application/json' \
              --data '{"text":"BharatBuild AI deployment FAILED. Check: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"}' \
              ${{ secrets.SLACK_WEBHOOK_URL }}
          fi

  # =============================================================================
  # Database Migration (Runs automatically before deployment)
  # =============================================================================
  migrate:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs: build
    if: |
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/production') &&
      needs.build.result == 'success'
    # Removed environment protection to allow migration without approval
    continue-on-error: true

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install migration dependencies
        working-directory: ./backend
        run: |
          pip install --upgrade pip
          pip install alembic psycopg2-binary sqlalchemy pydantic-settings python-dotenv

      - name: Run migrations directly
        working-directory: ./backend
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
          CELERY_BROKER_URL: ${{ secrets.CELERY_BROKER_URL }}
          CELERY_RESULT_BACKEND: ${{ secrets.CELERY_RESULT_BACKEND }}
          USER_PROJECTS_PATH: /tmp/projects
        run: |
          echo "============================================"
          echo "  Running Database Migrations"
          echo "============================================"

          # Show current migration status
          echo "Current migration status:"
          alembic current || echo "No current revision (fresh database)"

          # Run migrations
          echo ""
          echo "Applying migrations..."
          alembic upgrade head

          # Show new status
          echo ""
          echo "New migration status:"
          alembic current

          echo ""
          echo "============================================"
          echo "  Migrations Completed Successfully!"
          echo "============================================"

      - name: Verify database schema
        working-directory: ./backend
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
          CELERY_BROKER_URL: ${{ secrets.CELERY_BROKER_URL }}
          CELERY_RESULT_BACKEND: ${{ secrets.CELERY_RESULT_BACKEND }}
          USER_PROJECTS_PATH: /tmp/projects
        run: |
          python -c "
          from sqlalchemy import create_engine, inspect
          import os

          db_url = os.environ['DATABASE_URL']
          if '+asyncpg' in db_url:
              db_url = db_url.replace('+asyncpg', '')

          engine = create_engine(db_url)
          inspector = inspect(engine)
          tables = inspector.get_table_names()

          print('Database Tables:')
          for table in sorted(tables):
              print(f'  - {table}')
          print(f'\\nTotal: {len(tables)} tables')
          "

  # =============================================================================
  # Rollback (Manual)
  # =============================================================================
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && failure()
    needs: deploy-production
    environment: production

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Rollback to previous version
        run: |
          echo "Rolling back to previous task definition revision..."

          # Get previous backend revision
          BACKEND_REVISION=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.BACKEND_SERVICE }} \
            --query 'services[0].taskDefinition' \
            --output text | sed 's/:.*/:/' | xargs -I {} aws ecs list-task-definitions \
            --family-prefix bharatbuild-backend \
            --sort DESC \
            --query 'taskDefinitionArns[1]' \
            --output text)

          if [ -n "$BACKEND_REVISION" ]; then
            echo "Rolling back backend to: $BACKEND_REVISION"
            aws ecs update-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service ${{ env.BACKEND_SERVICE }} \
              --task-definition $BACKEND_REVISION
          fi
